```js:渡した値
const importObject = {
  js: {
    log_i32: value => console.log("i32 ", value),
    log_i64: value => console.log("i64 ", value),
    log_f32: value => console.log("f32 ", value),
    log_f64: value => console.log("f64 ", value)
  },
  env: {
    import_i32: 5_000_000_000,
    import_i64: BigInt(5_000_000_000),
    import_f32: 123.0123456789,
    import_f64: 123.0123456789
  }
}
```

```bash:結果
i32  705032704
i64  5000000000n
f32  123.01234436035156
f64  123.0123456789
```

# i32

- 32ビット符号なし整数の最大値が`4_294_967_295`
- この値に1を足すと、32ビット整数は0に戻ってしまう
- つまり、`5_000_000_000 - 4_294_967_295 = 705_032_704`

数十億を超える値を扱っている場合は、32ビット整数では対処できない

# i64

ES2021で追加された`BigInt`を使うと、64ビット整数のやり取りを実現できる

# f32

JSやWASMの32ビット浮動小数点数は、数値を表すために23ビットを使い、その値に２を8ビットの指数値で冪乗したものをかける
あくまでも近似にすぎず、精度は限られている

# f64

f32より圧倒的に近似計算がマシ
モバイルデバイスによっては、f32の方がパフォーマンスははるかによくなる

# int VS float

- 加減乗は整数で行う方が3~5倍ほど高速
- 2の冪乗による除算も整数の方が数倍高速
- 2の冪乗以外による除算は浮動小数点数の方が高速になることがある